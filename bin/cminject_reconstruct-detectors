#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# This file is part of CMInject
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# If you use this program for scientific work, you should correctly reference it; see LICENSE file for details.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program. If not, see
# <http://www.gnu.org/licenses/>.

import argparse
import logging

import h5py

from cminject.definitions.result_storage import HDF5ResultStorage
from cminject.utils.interpolation import reconstruct_detector_hits

program_description = """
Reconstructs virtual detectors at some fixed z positions for an arbitrary set of
quantities, based on stored trajectories. The trajectory path is sliced into
pieces that can be considered 1D functions f_i(z) for each reconstructed
quantity i, and an interpolating function is constructed and called on each
such piece. Resultant detectors are written to the `reconstructed_detectors`
dataset in the given result file, with their z position as keys. Interpolation
can be either linear or based on cubic splines.
"""


def main():
    parser = argparse.ArgumentParser(prog='cminject_reconstruct-detectors', description=program_description,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('file', help='The HDF5 file with trajectories to reconstruct detectors for.',
                        type=str, metavar='infile')
    parser.add_argument('--zi', help='The Z dimension index', type=int, required=True, metavar='zindex')
    parser.add_argument('--xis', help='The X/Y/... dimensions indices', type=int, required=True, nargs='+')
    parser.add_argument('--zs', help='The Z positions to reconstruct', type=float, required=True, nargs='+')
    parser.add_argument('--abs', help='Dimension indices to take absolute values of', type=int, nargs='*')
    parser.add_argument('--interpolation-kind', help='The interpolation kind to use.',
                        choices={'linear', 'cubic'}, default='linear')
    args = parser.parse_args()

    logging.basicConfig(format='%(levelname)s:[%(filename)s/%(funcName)s] %(message)s', level=logging.INFO)
    with h5py.File(args.file, 'r+') as h5f:
        zs = args.zs
        trajectories = HDF5ResultStorage(args.file, 'r').get_trajectories_iterator(abs_indices=args.abs)
        logging.info(f"Reconstructing at {zs}...")
        detectors = reconstruct_detector_hits(
            trajectories, xdims=args.xis, zdim=args.zi, zs=zs,
            interpolation_kind=args.interpolation_kind
        )
        for z, detector in zip(zs, detectors):
            h5f[f'reconstructed_detectors/{z}'] = detector
            logging.info(f'Detector at z = {z}: {detector.shape}')


if __name__ == '__main__':
    main()
